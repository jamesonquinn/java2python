module java/pp2py/main
imports
  libstratego-lib
  libstratego-gpp
  java/signature/v5
  java/signature/eblock
  
  java/pp2py/helpers
  java/pp2py/statement
  java/pp2py/expression
  java/pp2py/literal
  java/pp2py/name
  java/pp2py/modifier

  java/pp2py/type/parameterized
  java/pp2py/type/variable
  java/pp2py/type/primitive
  java/pp2py/type/reference

  java/pp2py/class/enum-declaration
  java/pp2py/class/method-declaration

  java/pp2py/interface/annotation
  java/pp2py/interface/annotation-type
  
  java/pp2py/parenthesize

strategies

  /**
   * @type Java -> String
   */
  pp-java5-to-string =
    pp-java5-to-abox
    ; box2text-string(|80)

  /**
   * @type Java -> Box
   */
  pp-java5-to-abox =
    pp-java5-to-abox(fail)
    
  /**
   *  @param extension  Strategy that converts an aterm to an abox,
   *                    overriding the default pretty printing rules.
   */
  pp-java5-to-abox(extension) =    
    parenthesize-Java5
    ; bottomup(try(j2py))
    ; topdown(
        try(very-special-conflict)
        ; try(pp-comments(extension <+ java-to-box))
        ; repeat(j2py <+ extension <+ java-to-box)
      )

rules
 
  j2py: ExprStm(PreIncr(e))  -> H hs=1 [ ~e "+= 1"]
  j2py: ExprStm(PreDecr(e))  -> H hs=1 [ ~e "-= 1"]
  j2py: ExprStm(PostIncr(e)) -> H hs=1 [ ~e "+= 1"]
  j2py: ExprStm(PostDecr(e)) -> H hs=1 [ ~e "-= 1"]

rules

  very-special-conflict:
    Minus(Minus(e)) -> Minus(Parenthetical(Minus(e)))

  very-special-conflict:
    Plus(Plus(e)) -> Plus(Parenthetical(Plus(e)))

rules

  pp-comments(pprules) =
    ?t{a*}

    ; where(
        <fetch(?(Comment(_), s))> a*
      ; <pprules> t => b
      )

    ; if !b => V(_, _) then // block comments
        !|[ V vs=0 [s b] ]|
      else
        if <explode-string> s => cs@['/', '/' | _] then
          <trim(?'\n' + ?'\r' + ?' ' + ?'\t'); implode-string> cs => s1
          ; !|[ V vs=0 [b s1] ]|
        else // inline comments
          !|[ H hs=1 [b s] ]|
        end
      end
 
rules

  java-to-box:
    CompilationUnit(Some(package), imports, types) -> box |[ V vs=1 [~package V vs=0 [ ~*imports ] V vs=1 [ ~*types ]] ]|

  java-to-box:
    CompilationUnit(None(), imports, types) -> box |[ V vs=1 [V vs=0 [~*imports] V vs=1 [~*types]] ]|

  java-to-box:
    PackageDec(annos, name) -> V hs=0 [  H ["#" ~*annos KW["package"] H hs=0 [~name ]]]

rules

  java-to-box:
    TypeImportDec(TypeName(pname,Id(s))) -> H hs=1 [ "from" ~pname "import" s ]

  java-to-box:
    TypeImportOnDemandDec(pname) -> H hs=1 ["from " ~pname "import *"] 

  java-to-box:
    StaticImportDec(tname, Id(s)) -> H hs=1 ["from"  ~tname "import" s ] 

  java-to-box:
    StaticImportOnDemandDec(tname)  -> H hs=1 ["from" ~tname "import *" ] 

rules

  java-to-box:
    Semicolon() -> box |[ ";" ]|

  java-to-box:
    InterfaceDec(InterfaceDecHead(mods, Id(name), type-args, implements), body)
      ->
    V vs=0 [H hs=0 [~lit:name b*] b2 ""]
    where
      <type-params-to-boxes> type-args => b*
    ; <block-structure> (1, body) => b2

  java-to-box:
    ClassDec(ClassDecHead(mods, Id(name), type-args, extends, implements), body)
      ->
    V vs=0 [
      H hs=1 ["class" H hs=0 [~lit:name b* "(" ~extends "):"]]
      "" 
      ~body
      ""
    ]
    where
      <type-params-to-boxes> type-args => b*

  java-to-box:
    ClassBody(decs) -> <block-structure> (1, decs)

  java-to-box:
    None() -> box |[ H hs=0 [""] ]|

  java-to-box:
    Some(c) -> c

  java-to-box:
    SuperDec(c) -> box |[ H hs=1 ["(" ~c ")"] ]|

  java-to-box:
    ImplementsDec(is) -> box |[ H hs=1 [KW["implements"] ~interfaces] ]|
      where <separate-by-comma> is; ?interfaces

  java-to-box:
    ExtendsInterfaces(is) -> box |[ H hs=1 ["(" ~interfaces ")"] ]|
      where <separate-by-comma> is; ?interfaces

rules

  java-to-box:
    StaticInit(b)   -> box |[ V vs=0  [~b] ]|

  java-to-box:
    InstanceInit(b) -> box |[ V vs=1 [ "##InstanceInit" b ] ]|

rules

  java-to-box:
    AbstractMethodDec(mods, type-params, type, Id(n), params, throws)
      ->
    box |[ H hs=0 [ ~MethodDecHead(mods, type-params, type, Id(n), params, throws) ] ]|

  java-to-box:
    ConstrDec(ConstrDecHead(mods, type-params, class, params, throws), body)
      ->
    V vs=0 [H hs=0 ["def __init_" ~targboxes "(self, " ~args "): ##Should have been rewriten by j2py.py"] ~body ""]
    where 
      <list-to-args2> params => args 
    ; <type-params-to-boxes2> type-params => targboxes 
    ; !Conc(mods, targboxes) => foo 

  java-to-box:
    ConstrBody(None(), stms) -> <block-structure> (0, stms)

  java-to-box:
    ConstrBody(Some(cinvoke), stms) -> <block-structure> (0, [cinvoke | stms])

  java-to-box:
    FieldDec(mods, type, ds)
      ->
    H hs=1 [ H hs=0 ["self." ~decs /* "#001" */] ] 
    where
      <separate-by-comma> ds => decs

  java-to-box:
    ConstantDec(mods, type, ds) -> FieldDec(mods, type, ds)

  java-to-box:
    VarDec(i) -> H hs=1 [~i "= None" ]

  java-to-box:
    VarDec(i, init) -> H hs=1 [~i "=" ~init]

  java-to-box:
    Id(s) -> box |[ s ]|

  java-to-box:
    ArrayVarDecId(Id(s), b*) -> H hs=0 [s b*]

  java-to-box:
    Dim() -> H hs=0 ["range(0)"]

  java-to-box:
    Dim(e) -> H hs=0 ["range(" ~e ")"]

  java-to-box:
    ArrayInit(exprs) -> H hs=0 ["{#" ~vals "#}"]
    where
      <separate-by-comma> exprs => vals

  java-to-box:
    AltConstrInv(type-args, exprs) 
      -> H hs=0 [ "self" ~args " ##AltConstrInv" ]
    where
      <list-to-args> exprs => args
    ; <type-args-to-boxes> type-args => b1*

  java-to-box:
    SuperConstrInv(type-args, exprs) 
      -> box |[ H hs=0 [ "self.__bases__[0].__init__" b2 /* "##SuperConstrInv" */] ]|
    where
      <list-to-args3> exprs => b2
    ; <type-args-to-boxes> type-args => b1*

  java-to-box:
    QSuperConstrInv(b0, type-args, exprs) 
      -> box |[ H hs=0 [ "self.__bases__[0].__init__" b2 /* "##QSuerConstrInv" */ ] ]|
    where
      <list-to-args3> exprs => b2
    ; <type-args-to-boxes> type-args => b1*

  java-to-box :
    amb(alts) -> V vs=0[V vs=0 is=2 [ "##amb>" ~*alts' ] "##<amb"]
    where
      <map-with-index({s: \
         (i, b) -> H hs=1 [ H hs=0 [s ">"] b]
         where
           <int-to-string> i => s
       \})> alts => alts'

  java-to-box :
    PreEBlock(stms, e) -> V vs=0 [ "##PreEBlock" V is=2 ["|" ~*stms] H hs=1 ["|" ~e "|"]]

signature
  constructors
    Comment   : String -> AnnoKey
    amb       : List(A) -> A

    /**
     * Construct from Dryad. Dirty, but useful to have here.
     */
    Field     : Id -> Expr
